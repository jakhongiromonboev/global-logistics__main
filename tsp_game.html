<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP Navigator - The Cosmic Challenge</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Styles --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif; /* Futuristic font */
            background: linear-gradient(135deg, #0c0c2e 0%, #1a1a3a 50%, #2d2d5f 100%);
            color: white;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* --- Starry Background --- */
        #stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle linear infinite;
            box-shadow: 0 0 5px white; /* Add a subtle glow */
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        /* --- Main Container --- */
        .container {
            position: relative;
            z-index: 10;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        /* --- Header --- */
        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.08); /* Slightly more opaque */
            backdrop-filter: blur(12px); /* Stronger blur */
            border-radius: 20px; /* More rounded */
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15); /* Thicker border */
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.3); /* Blueish glow */
            animation: fadeInHeader 1s ease-out; /* New animation for header */
        }

        .header h1 {
            font-size: 3em; /* Larger title */
            margin-bottom: 12px;
            color: #87ceeb; /* Sky blue */
            text-shadow: 0 0 25px rgba(135, 206, 235, 0.8); /* Stronger glow */
            letter-spacing: 2px;
        }

        .header p {
            font-size: 1.1em;
            color: #c0c0c0;
        }

        /* --- Game Area Layout --- */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 320px; /* Slightly wider control panel */
            gap: 25px; /* Larger gap */
        }

        /* --- Canvas Container --- */
        .canvas-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        #gameCanvas {
            width: 100%;
            height: 550px; /* Taller canvas */
            background: rgba(0, 0, 0, 0.4); /* Darker background */
            border-radius: 15px;
            cursor: crosshair;
            border: 2px solid rgba(255, 255, 255, 0.25);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5); /* Inner shadow */
        }

        /* --- Control Panel --- */
        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            height: fit-content;
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        .control-section {
            margin-bottom: 25px; /* Larger margin */
            padding-bottom: 25px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2); /* Dashed border */
        }

        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .control-section h3 {
            margin-bottom: 18px;
            color: #87ceeb;
            text-shadow: 0 0 15px rgba(135, 206, 235, 0.7);
            font-size: 1.3em;
            letter-spacing: 1px;
        }

        /* --- Buttons --- */
        .btn {
            width: 100%;
            padding: 14px; /* Larger padding */
            margin: 10px 0; /* Larger margin */
            border: none;
            border-radius: 10px; /* More rounded */
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Stronger button shadow */
            text-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        .btn-primary {
            background: linear-gradient(45deg, #4a90e2, #7bb3f0); /* Blue gradient */
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(45deg, #357abd, #5a9bd4);
            transform: translateY(-3px) scale(1.02); /* More pronounced hover */
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #e74c3c, #f39c12); /* Orange/Red gradient */
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #c0392b, #d68910);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.6);
        }

        .btn-success {
            background: linear-gradient(45deg, #27ae60, #2ecc71); /* Green gradient */
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(45deg, #1e8449, #25a25a);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.6);
        }

        /* --- Info Display --- */
        .info-display {
            background: rgba(0, 0, 0, 0.5); /* Darker, more solid background */
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 5px solid #00ffff; /* Cyan accent */
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.3); /* Inner cyan glow */
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 15px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.1); /* Subtle separator */
            padding-bottom: 5px;
        }
        .info-item:last-child { border-bottom: none; }


        .info-label {
            color: #87ceeb;
            font-weight: normal;
        }

        .info-value {
            font-weight: bold;
            color: #00ffff; /* Cyan for values */
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }

        /* --- Animations --- */
        .phase {
            opacity: 0;
            transform: translateY(30px); /* Larger initial translation */
            transition: opacity 0.8s ease-out, transform 0.8s ease-out; /* Slower, smoother animation */
        }

        .phase.visible {
            opacity: 1;
            transform: translateY(0);
        }

        @keyframes fadeInHeader {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Instructions --- */
        .instructions {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 25px;
            margin-top: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        .instructions h3 {
            color: #87ceeb;
            margin-bottom: 18px;
            text-shadow: 0 0 15px rgba(135, 206, 235, 0.7);
            font-size: 1.3em;
            letter-spacing: 1px;
        }

        .instructions ul {
            list-style: none;
            padding-left: 0;
        }

        .instructions li {
            margin: 10px 0;
            padding-left: 25px; /* More space for bullet */
            position: relative;
            font-size: 0.95em;
            color: #c0c0c0;
        }

        .instructions li:before {
            content: "üöÄ"; /* More thematic bullet */
            position: absolute;
            left: 0;
            color: #00ffff; /* Cyan rocket */
            font-size: 1.2em;
        }

        /* --- Scoreboard/Game Feedback --- */
        #gameFeedback {
            text-align: center;
            margin-top: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #2ecc71; /* Green for success */
            text-shadow: 0 0 15px rgba(46, 204, 113, 0.7);
            min-height: 30px; /* Reserve space */
        }

        #starRating {
            margin-top: 10px;
            font-size: 2.5em;
            color: gold;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            display: none; /* Hidden by default */
        }

        /* --- Responsive Design --- */
        @media (max-width: 992px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 576px) {
            .header h1 {
                font-size: 2em;
            }
            .container {
                padding: 10px;
            }
            .control-panel, .canvas-container, .header, .instructions {
                padding: 15px;
            }
            .btn {
                padding: 10px;
                font-size: 13px;
            }
            .info-item {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div id="stars"></div>
    
    <div class="container">
        <div class="header phase">
            <h1>üåü TSP Navigator: The Cosmic Challenge üåü</h1>
            <p>Plot your flight path and find the shortest route through all stellar cities!</p>
        </div>

        <div class="game-area phase">
            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>
            
            <div class="control-panel">
                <div class="control-section">
                    <h3>üéÆ Navigation Controls</h3>
                    <button class="btn btn-primary" onclick="window.tspGame.resetPlayerRoute()">Reset My Route</button>
                    <button class="btn btn-success" onclick="window.tspGame.submitPlayerRoute()">Submit My Route</button>
                    <button class="btn btn-secondary" onclick="window.tspGame.solveTSP()">Show Optimal Route</button>
                </div>

                <div class="control-section">
                    <h3>üåå Stellar Map</h3>
                    <button class="btn btn-primary" onclick="window.tspGame.clearCities()">Clear All Cities</button>
                    <button class="btn btn-secondary" onclick="window.tspGame.generateRandomCities()">New Random Cities</button>
                    <div style="display: flex; gap: 5px; margin-top: 10px;">
                        <button class="btn btn-primary" style="flex: 1;" onclick="window.tspGame.generateRandomCities(5)">5 Stars</button>
                        <button class="btn btn-primary" style="flex: 1;" onclick="window.tspGame.generateRandomCities(8)">8 Stars</button>
                        <button class="btn btn-primary" style="flex: 1;" onclick="window.tspGame.generateRandomCities(12)">12 Stars</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üìä Mission Briefing</h3>
                    <div class="info-display">
                        <div class="info-item">
                            <span class="info-label">Cities Discovered:</span>
                            <span class="info-value" id="cityCount">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">My Path Length:</span>
                            <span class="info-value" id="playerDistance">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Optimal Path:</span>
                            <span class="info-value" id="bestDistance">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Current Goal:</span>
                            <span class="info-value" id="goalMessage">Plot a path!</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gameFeedback"></div>
        <div id="starRating"></div>

        <div class="instructions phase">
            <h3>üéØ Mission Objectives</h3>
            <ul>
                <li>üöÄ **Click on the nebula** to establish new star cities.</li>
                <li>‚≠ê **Click on cities in sequence** to plot your navigation route. Click the first city again to complete the loop.</li>
                <li>‚úÖ **"Submit My Route"** to see how your path compares to the supercomputer's optimal solution.</li>
                <li>üß† **"Show Optimal Route"** reveals the shortest path found by the algorithm.</li>
                <li>üîÑ Use **"Reset My Route"** to clear your path and try again.</li>
                <li>‚ú® Earn **star ratings** based on how close your path is to the optimal!</li>
            </ul>
        </div>
    </div>

    <script>
        // --- Animated Stars Background ---
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const numStars = 200; // More stars for a richer background
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = (Math.random() * 3 + 1) + 'px'; // Vary star size
                star.style.animationDelay = Math.random() * 5 + 's';
                star.style.animationDuration = (Math.random() * 4 + 3) + 's'; // Vary twinkle speed
                starsContainer.appendChild(star);
            }
        }

        // --- TSP Game Logic ---
        class TSPGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cities = [];
                this.playerRoute = []; // Stores indices of cities in player's path
                this.optimalRoute = [];
                this.optimalDistance = Infinity;
                this.playerDistance = 0;
                this.currentHoverCity = null; // For hover effect on cities

                this.setupCanvas();
                this.bindEvents();
                this.updateStats();
                this.draw();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width *= dpr;
                this.canvas.height *= dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }

            bindEvents() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Check if clicked on an existing city
                    let clickedCityIndex = -1;
                    for (let i = 0; i < this.cities.length; i++) {
                        const city = this.cities[i];
                        const distance = Math.sqrt(Math.pow(mouseX - city.x, 2) + Math.pow(mouseY - city.y, 2));
                        if (distance <= 15) { // City radius for clicking
                            clickedCityIndex = i;
                            break;
                        }
                    }

                    if (clickedCityIndex !== -1) {
                        this.addCityToPlayerRoute(clickedCityIndex);
                    } else {
                        // Add new city if not clicking existing one
                        this.addCity(mouseX, mouseY);
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    let hoverCityFound = false;

                    for (let i = 0; i < this.cities.length; i++) {
                        const city = this.cities[i];
                        const distance = Math.sqrt(Math.pow(mouseX - city.x, 2) + Math.pow(mouseY - city.y, 2));
                        if (distance <= 15) {
                            if (this.currentHoverCity !== i) {
                                this.currentHoverCity = i;
                                this.draw(); // Redraw to show hover effect
                            }
                            hoverCityFound = true;
                            break;
                        }
                    }
                    if (!hoverCityFound && this.currentHoverCity !== null) {
                        this.currentHoverCity = null;
                        this.draw(); // Redraw to remove hover effect
                    }
                });

                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.draw();
                });
            }

            addCity(x, y) {
                this.cities.push({ x, y, id: this.cities.length });
                this.resetPlayerRoute(); // Reset player route on new city
                this.optimalRoute = []; // Clear optimal route
                this.optimalDistance = Infinity; // Reset optimal distance
                this.updateStats();
                this.draw();
            }

            addCityToPlayerRoute(cityIndex) {
                // If route is empty or the last city is different, add it
                if (this.playerRoute.length === 0 || this.playerRoute[this.playerRoute.length - 1] !== cityIndex) {
                    this.playerRoute.push(cityIndex);
                    this.playerDistance = this.calculateRouteDistance(this.playerRoute, false); // Don't loop until submitted
                    this.updateStats();
                    this.draw();
                    document.getElementById('gameFeedback').textContent = ''; // Clear feedback
                    document.getElementById('starRating').style.display = 'none';
                } else if (this.playerRoute.length > 1 && this.playerRoute[0] === cityIndex) {
                    // If clicking the first city again to complete the loop
                    this.submitPlayerRoute();
                }
            }

            resetPlayerRoute() {
                this.playerRoute = [];
                this.playerDistance = 0;
                document.getElementById('gameFeedback').textContent = '';
                document.getElementById('starRating').style.display = 'none';
                this.updateStats();
                this.draw();
            }

            submitPlayerRoute() {
                if (this.cities.length < 2) {
                    document.getElementById('gameFeedback').textContent = 'Need at least 2 cities to submit a route!';
                    return;
                }
                if (this.playerRoute.length !== this.cities.length) {
                    document.getElementById('gameFeedback').textContent = 'Visit all cities before submitting!';
                    return;
                }
                // Ensure the route is a full cycle (ends back at start)
                if (this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1] && this.playerRoute.length > 1) {
                     // If player hasn't explicitly clicked back to start, add it
                    if (this.playerRoute.filter((v, i, a) => a.indexOf(v) === i).length === this.cities.length) {
                        // All unique cities visited, just close the loop visually for scoring
                        this.playerRoute.push(this.playerRoute[0]);
                    } else {
                        document.getElementById('gameFeedback').textContent = 'Visit all unique cities and close the loop!';
                        return;
                    }
                }
                
                this.playerDistance = this.calculateRouteDistance(this.playerRoute, true);
                this.solveTSP(); // Immediately calculate optimal route for comparison

                this.updateStats();
                this.draw(); // Redraw with final player route

                this.giveFeedback();
            }

            giveFeedback() {
                const feedbackDiv = document.getElementById('gameFeedback');
                const starRatingDiv = document.getElementById('starRating');
                starRatingDiv.style.display = 'block';

                if (this.optimalDistance === Infinity || this.optimalDistance === 0) {
                    feedbackDiv.textContent = 'Please solve for optimal route first.';
                    starRatingDiv.textContent = '';
                    return;
                }

                const playerRatio = this.playerDistance / this.optimalDistance;

                if (playerRatio <= 1.0) {
                    feedbackDiv.textContent = 'üöÄ Perfect Navigation! You found the optimal path!';
                    starRatingDiv.textContent = 'üåüüåüüåü';
                } else if (playerRatio <= 1.15) { // Within 15% of optimal
                    feedbackDiv.textContent = '‚ú® Excellent Pilot! A near-optimal path!';
                    starRatingDiv.textContent = 'üåüüåü';
                } else if (playerRatio <= 1.30) { // Within 30% of optimal
                    feedbackDiv.textContent = '‚≠ê Good Effort! You\'re getting closer!';
                    starRatingDiv.textContent = 'üåü';
                } else {
                    feedbackDiv.textContent = 'Keep Exploring! Try to find a shorter route.';
                    starRatingDiv.textContent = 'üòî';
                }
            }


            clearCities() {
                this.cities = [];
                this.resetPlayerRoute();
                this.optimalRoute = [];
                this.optimalDistance = Infinity;
                document.getElementById('gameFeedback').textContent = '';
                document.getElementById('starRating').style.display = 'none';
                this.updateStats();
                this.draw();
            }

            generateRandomCities(count = 8) {
                this.clearCities();
                const margin = 50;
                const width = this.canvas.offsetWidth - 2 * margin;
                const height = this.canvas.offsetHeight - 2 * margin;

                for (let i = 0; i < count; i++) {
                    const x = margin + Math.random() * width;
                    const y = margin + Math.random() * height;
                    this.cities.push({ x, y, id: i });
                }
                this.updateStats();
                this.draw();
            }

            calculateDistance(city1, city2) {
                const dx = city1.x - city2.x;
                const dy = city1.y - city2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            calculateRouteDistance(routeIndices, loop = true) {
                if (routeIndices.length < 2) return 0;
                
                let distance = 0;
                for (let i = 0; i < routeIndices.length - 1; i++) {
                    distance += this.calculateDistance(this.cities[routeIndices[i]], this.cities[routeIndices[i + 1]]);
                }
                // If looping, add distance back to start
                if (loop && routeIndices.length > 0) {
                    distance += this.calculateDistance(this.cities[routeIndices[routeIndices.length - 1]], this.cities[routeIndices[0]]);
                }
                return distance;
            }

            // Using Nearest Neighbor as it's computationally lighter for many cities
            nearestNeighborTSP() {
                if (this.cities.length < 2) return [];

                const unvisited = new Set(Array.from({ length: this.cities.length }, (_, i) => i));
                const route = [];
                let currentCityIndex = 0; // Start at city 0

                route.push(currentCityIndex);
                unvisited.delete(currentCityIndex);

                while (unvisited.size > 0) {
                    let nearest = -1;
                    let nearestDistance = Infinity;

                    for (const cityIndex of unvisited) {
                        const distance = this.calculateDistance(this.cities[currentCityIndex], this.cities[cityIndex]);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearest = cityIndex;
                        }
                    }
                    route.push(nearest);
                    unvisited.delete(nearest);
                    currentCityIndex = nearest;
                }
                return route;
            }
            
            // For a small number of cities, we can try brute force for true optimal (N! permutations)
            // Warning: Be very careful with `bruteForceTSP` as it's extremely slow for N > 10-12
            bruteForceTSP() {
                const numCities = this.cities.length;
                if (numCities < 2) return [];
                if (numCities > 10) { // Limit for performance
                    console.warn("Brute force is too slow for more than 10 cities. Using Nearest Neighbor.");
                    return this.nearestNeighborTSP();
                }

                let smallestDistance = Infinity;
                let bestPermutation = [];

                // Generate all permutations using Heap's algorithm
                function permute(arr, l, r) {
                    if (l === r) {
                        const currentDistance = this.calculateRouteDistance(arr, true);
                        if (currentDistance < smallestDistance) {
                            smallestDistance = currentDistance;
                            bestPermutation = [...arr];
                        }
                    } else {
                        for (let i = l; i <= r; i++) {
                            [arr[l], arr[i]] = [arr[i], arr[l]]; // Swap
                            permute.call(this, arr, l + 1, r);
                            [arr[l], arr[i]] = [arr[i], arr[l]]; // Backtrack
                        }
                    }
                }

                const initialPermutation = Array.from({ length: numCities }, (_, i) => i);
                permute.call(this, initialPermutation, 0, numCities - 1);
                
                return bestPermutation;
            }


            solveTSP() {
                if (this.cities.length < 2) {
                    document.getElementById('gameFeedback').textContent = 'Add more cities to find an optimal route!';
                    return;
                }
                document.getElementById('gameFeedback').textContent = 'Calculating optimal route...';

                // Use brute force for small N, Nearest Neighbor for larger N
                // The current problem statement only asks for Nearest Neighbor.
                // If you want true optimal, uncomment bruteForceTSP and adjust threshold.
                const route = this.cities.length <= 8 ? this.bruteForceTSP() : this.nearestNeighborTSP(); // Adjust threshold as needed
                
                // If using nearest neighbor and optimal is already calculated by player, keep it for comparison
                // Otherwise, this.optimalRoute is set by solveTSP.
                if (this.optimalDistance === Infinity || this.cities.length > 8) { // If using NN, or if brute force wasn't run
                    this.optimalDistance = this.calculateRouteDistance(route, true);
                    this.optimalRoute = route;
                }

                this.updateStats();
                this.draw();
                document.getElementById('gameFeedback').textContent = 'Optimal route displayed!';
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw optimal route (if exists)
                if (this.optimalRoute.length > 1 && this.optimalDistance < Infinity) {
                    this.ctx.strokeStyle = '#FFD700'; // Gold color for optimal
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([5, 5]); // Dashed line for optimal
                    this.ctx.beginPath();
                    for (let i = 0; i < this.optimalRoute.length; i++) {
                        const city = this.cities[this.optimalRoute[i]];
                        if (i === 0) {
                            this.ctx.moveTo(city.x, city.y);
                        } else {
                            this.ctx.lineTo(city.x, city.y);
                        }
                    }
                    if (this.optimalRoute.length > 0) {
                        const firstCity = this.cities[this.optimalRoute[0]];
                        this.ctx.lineTo(firstCity.x, firstCity.y);
                    }
                    this.ctx.stroke();
                }
                
                // Draw player's current route
                if (this.playerRoute.length > 1) {
                    this.ctx.strokeStyle = '#00ffff'; // Cyan for player's route
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([]); // Solid line for player
                    this.ctx.beginPath();
                    for (let i = 0; i < this.playerRoute.length; i++) {
                        const city = this.cities[this.playerRoute[i]];
                        if (i === 0) {
                            this.ctx.moveTo(city.x, city.y);
                        } else {
                            this.ctx.lineTo(city.x, city.y);
                        }
                    }
                    // Only draw connecting line to start if route is complete for display
                    if (this.playerRoute.length === this.cities.length && this.playerRoute[0] === this.playerRoute[this.playerRoute.length - 1]) {
                        const firstCity = this.cities[this.playerRoute[0]];
                        this.ctx.lineTo(firstCity.x, firstCity.y);
                    } else if (this.playerRoute.length === this.cities.length && this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1]){
                        // If all cities visited but not explicitly closed, draw the closing line for player to see
                         const firstCity = this.cities[this.playerRoute[0]];
                         const lastCity = this.cities[this.playerRoute[this.playerRoute.length - 1]];
                         this.ctx.lineTo(firstCity.x, firstCity.y);
                    }
                    this.ctx.stroke();

                    // Draw direction arrows for player route
                    this.drawDirectionArrows(this.playerRoute, '#00ffff');
                }

                // Draw cities
                this.cities.forEach((city, index) => {
                    // City glow (larger for hover)
                    const radius = (this.currentHoverCity === index) ? 18 : 15;
                    const glowGradient = this.ctx.createRadialGradient(city.x, city.y, 0, city.x, city.y, radius);
                    glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    glowGradient.addColorStop(0.7, (this.currentHoverCity === index) ? '#00ffff' : '#87ceeb');
                    glowGradient.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = glowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(city.x, city.y, radius, 0, 2 * Math.PI);
                    this.ctx.fill();

                    // City core
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(city.x, city.y, 8, 0, 2 * Math.PI);
                    this.ctx.fill();

                    // City number
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = 'bold 13px Orbitron'; /* Font for city numbers */
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText((index + 1).toString(), city.x, city.y);
                });
            }

            drawDirectionArrows(routeIndices, color) {
                if (routeIndices.length < 2) return;

                this.ctx.fillStyle = color;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;

                // Loop up to routeIndices.length - 1 for regular segments,
                // and then explicitly handle closing segment if playerRoute is complete
                let segmentsToDraw = routeIndices.length - 1;
                if (routeIndices.length === this.cities.length && routeIndices[0] !== routeIndices[routeIndices.length - 1]) {
                    // If all unique cities visited but not closed, show closing arrow.
                    // This is to guide the player to click the first city.
                    segmentsToDraw++; // Add one more segment for the closing line
                } else if (routeIndices.length > 1 && routeIndices[0] === routeIndices[routeIndices.length - 1]) {
                    // If the route is explicitly closed, loop one less for array access
                    segmentsToDraw = routeIndices.length - 1;
                }


                for (let i = 0; i < segmentsToDraw; i++) {
                    const currentCity = this.cities[routeIndices[i]];
                    const nextCity = this.cities[routeIndices[(i + 1) % routeIndices.length]]; // This handles the loop automatically if route is complete and closed
                    
                    // Special handling for the closing segment if the player just finished visiting all cities
                    let finalNextCity = nextCity;
                    if (i === routeIndices.length - 1 && routeIndices.length === this.cities.length && routeIndices[0] !== routeIndices[routeIndices.length - 1]) {
                        finalNextCity = this.cities[routeIndices[0]]; // Draw arrow back to the start city
                    }

                    const dx = finalNextCity.x - currentCity.x;
                    const dy = finalNextCity.y - currentCity.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 30) {
                        const midX = currentCity.x + dx * 0.5; // Midpoint for arrow
                        const midY = currentCity.y + dy * 0.5;

                        const angle = Math.atan2(dy, dx);
                        const arrowLength = 10;
                        const arrowAngle = 0.5;

                        this.ctx.beginPath();
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle - arrowAngle),
                            midY - arrowLength * Math.sin(angle - arrowAngle)
                        );
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle + arrowAngle),
                            midY - arrowLength * Math.sin(angle + arrowAngle)
                        );
                        this.ctx.stroke();
                    }
                }
            }


            updateStats() {
                document.getElementById('cityCount').textContent = this.cities.length;
                document.getElementById('playerDistance').textContent =
                    this.playerDistance > 0 ? Math.round(this.playerDistance) : '0';
                document.getElementById('bestDistance').textContent =
                    this.optimalDistance < Infinity ? Math.round(this.optimalDistance) : '-';
                
                // Update goal message
                const goalMessageElement = document.getElementById('goalMessage');
                if (this.cities.length === 0) {
                    goalMessageElement.textContent = 'Place cities!';
                } else if (this.playerRoute.length === 0) {
                    goalMessageElement.textContent = 'Start plotting!';
                } else if (this.playerRoute.filter((v, i, a) => a.indexOf(v) === i).length < this.cities.length) {
                    goalMessageElement.textContent = 'Visit all cities!';
                } else if (this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1]) {
                    goalMessageElement.textContent = 'Close the loop!';
                } else {
                    goalMessageElement.textContent = 'Submit your path!';
                }
            }
        }

        // --- Initialize everything when page loads ---
        document.addEventListener('DOMContentLoaded', function () {
            createStars();
            window.tspGame = new TSPGame();
            
            // Initial animation for sections
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1 }); // Trigger when 10% of element is visible

            document.querySelectorAll('.phase').forEach(phase => {
                observer.observe(phase);
            });
        });
    </script>
</body>
</html>
