<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP Navigator - The Cosmic Challenge</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Styles --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif; /* Futuristic font */
            background: #0d0d1e; /* Dark base for space */
            color: white;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* Needed for absolute positioning of background elements */
        }

        /* --- Dynamic Space Background --- */
        .background-gradient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a2a, #1a0a3a, #0a1a3a); /* Deep space gradient */
            background-size: 400% 400%; /* Larger size for animation */
            animation: gradientShift 25s ease infinite; /* Slower, smoother animation */
            z-index: 0;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 0%; }
            50% { background-position: 100% 100%; }
            100% { background-position: 0% 0%; }
        }

        #stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1; /* Above gradient, below content */
            overflow: hidden;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle linear infinite;
            box-shadow: 0 0 5px white; /* Add a subtle glow */
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        /* --- Main Container --- */
        .container {
            position: relative;
            z-index: 10; /* Ensure content is above background */
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        /* --- Header --- */
        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.3);
            animation: fadeInHeader 1s ease-out;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 12px;
            color: #87ceeb;
            text-shadow: 0 0 25px rgba(135, 206, 235, 0.8);
            letter-spacing: 2px;
        }

        .header p {
            font-size: 1.1em;
            color: #c0c0c0;
        }

        /* --- Game Area Layout --- */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 25px;
        }

        /* --- Canvas Container --- */
        .canvas-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        #gameCanvas {
            width: 100%;
            height: 550px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            cursor: crosshair;
            border: 2px solid rgba(255, 255, 255, 0.25);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
        }

        /* --- Control Panel --- */
        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            height: fit-content;
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .control-section h3 {
            margin-bottom: 18px;
            color: #87ceeb;
            text-shadow: 0 0 15px rgba(135, 206, 235, 0.7);
            font-size: 1.3em;
            letter-spacing: 1px;
        }

        /* --- Buttons --- */
        .btn {
            width: 100%;
            padding: 14px;
            margin: 10px 0;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        .btn-primary {
            background: linear-gradient(45deg, #4a90e2, #7bb3f0);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(45deg, #357abd, #5a9bd4);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #c0392b, #d68910);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.6);
        }

        .btn-success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(45deg, #1e8449, #25a25a);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.6);
        }

        /* --- Info Display --- */
        .info-display {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 5px solid #00ffff;
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 15px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.1);
            padding-bottom: 5px;
        }
        .info-item:last-child { border-bottom: none; }


        .info-label {
            color: #87ceeb;
            font-weight: normal;
        }

        .info-value {
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }

        /* --- Fuel Gauge --- */
        .fuel-gauge-container {
            width: 100%;
            height: 25px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            overflow: hidden;
            margin-top: 10px;
            position: relative;
            box-shadow: inset 0 0 5px rgba(0, 255, 255, 0.5);
        }

        #fuelGauge {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #2ecc71);
            border-radius: 12px;
            transition: width 0.3s ease-out;
            transform-origin: left;
        }
        #fuelGauge.empty {
            background: #e74c3c;
        }
        #fuelLabel {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 25px;
            font-size: 12px;
            color: white;
            text-shadow: 0 0 3px black;
        }


        /* --- Animations --- */
        .phase {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        }

        .phase.visible {
            opacity: 1;
            transform: translateY(0);
        }

        @keyframes fadeInHeader {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Instructions --- */
        .instructions {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 25px;
            margin-top: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        .instructions h3 {
            color: #87ceeb;
            margin-bottom: 18px;
            text-shadow: 0 0 15px rgba(135, 206, 235, 0.7);
            font-size: 1.3em;
            letter-spacing: 1px;
        }

        .instructions ul {
            list-style: none;
            padding-left: 0;
        }

        .instructions li {
            margin: 10px 0;
            padding-left: 25px;
            position: relative;
            font-size: 0.95em;
            color: #c0c0c0;
        }

        .instructions li:before {
            content: "üöÄ";
            position: absolute;
            left: 0;
            color: #00ffff;
            font-size: 1.2em;
        }

        /* --- Scoreboard/Game Feedback --- */
        #gameFeedback {
            text-align: center;
            margin-top: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #2ecc71;
            text-shadow: 0 0 15px rgba(46, 204, 113, 0.7);
            min-height: 30px;
        }

        #starRating {
            margin-top: 10px;
            font-size: 2.5em;
            color: gold;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            display: none;
        }

        /* --- Responsive Design --- */
        @media (max-width: 992px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 576px) {
            .header h1 {
                font-size: 2em;
            }
            .container {
                padding: 10px;
            }
            .control-panel, .canvas-container, .header, .instructions {
                padding: 15px;
            }
            .btn {
                padding: 10px;
                font-size: 13px;
            }
            .info-item {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="background-gradient"></div>
    <div id="stars"></div>
    
    <div class="container">
        <div class="header phase">
            <h1>üåü TSP Navigator: The Cosmic Challenge üåü</h1>
            <p>Plot your flight path and find the shortest route through all stellar cities!</p>
        </div>

        <div class="game-area phase">
            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>
            
            <div class="control-panel">
                <div class="control-section">
                    <h3>üéÆ Navigation Controls</h3>
                    <button class="btn btn-primary" id="resetRouteBtn">Reset My Route</button>
                    <button class="btn btn-success" id="submitRouteBtn">Submit My Route</button>
                    <button class="btn btn-secondary" id="showOptimalBtn">Show Optimal Route</button>
                </div>

                <div class="control-section">
                    <h3>üåå Stellar Map</h3>
                    <button class="btn btn-primary" id="clearCitiesBtn">Clear All Cities</button>
                    <button class="btn btn-secondary" id="randomCitiesBtn">New Random Cities (Default)</button>
                    <div style="display: flex; gap: 5px; margin-top: 10px;">
                        <button class="btn btn-primary" id="random5CitiesBtn">5 Stars</button>
                        <button class="btn btn-primary" id="random8CitiesBtn">8 Stars</button>
                        <button class="btn btn-primary" id="random12CitiesBtn">12 Stars</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üìä Mission Briefing</h3>
                    <div class="info-display">
                        <div class="info-item">
                            <span class="info-label">Cities Discovered:</span>
                            <span class="info-value" id="cityCount">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">My Path Length:</span>
                            <span class="info-value" id="playerDistance">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Optimal Path:</span>
                            <span class="info-value" id="bestDistance">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Current Goal:</span>
                            <span class="info-value" id="goalMessage">Plot a path!</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Fuel Remaining:</span>
                            <div class="fuel-gauge-container">
                                <div id="fuelGauge"></div>
                                <span id="fuelLabel"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gameFeedback"></div>
        <div id="starRating"></div>

        <div class="instructions phase">
            <h3>üéØ Mission Objectives</h3>
            <ul>
                <li>üöÄ **Click on the nebula** to establish new star cities.</li>
                <li>‚≠ê **Click on cities in sequence** to plot your navigation route. Click the first city again to complete the loop.</li>
                <li>‚õΩ **Watch your fuel!** Each jump consumes fuel. Reach all cities and close the loop before running out!</li>
                <li>‚úÖ **"Submit My Route"** to see how your path compares to the supercomputer's optimal solution.</li>
                <li>üß† **"Show Optimal Route"** reveals the shortest path found by the algorithm. (Note: For >8 cities, this uses a faster, but not always optimal, approximation).</li>
                <li>üîÑ Use **"Reset My Route"** to clear your path and try again.</li>
                <li>‚ú® Earn **star ratings** based on how close your path is to the optimal!</li>
            </ul>
        </div>
    </div>

    <script>
        // --- Animated Stars Background ---
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const numStars = 200; // More stars for a richer background
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = (Math.random() * 3 + 1) + 'px'; // Vary star size
                star.style.animationDelay = Math.random() * 5 + 's';
                star.style.animationDuration = (Math.random() * 4 + 3) + 's'; // Vary twinkle speed
                starsContainer.appendChild(star);
            }
        }

        // --- TSP Game Logic ---
        class TSPGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cities = [];
                this.playerRoute = []; // Stores indices of cities in player's path
                this.optimalRoute = [];
                this.optimalDistance = Infinity;
                this.playerDistance = 0;
                this.currentHoverCity = null; // For hover effect on cities
                this.animationFrameId = null; // To manage animations for line drawing
                this.cityAnimationIds = new Map(); // To manage multiple city warp-in animations

                // Fuel System
                this.maxFuel = 1000;
                this.currentFuel = this.maxFuel;
                this.fuelConsumptionPerUnitDistance = 0.5; // Adjust this value for difficulty (lower is easier)

                this.setupCanvas();
                this.bindEvents();
                this.updateStats();
                this.draw(); // Initial draw
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width *= dpr;
                this.canvas.height *= dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }

            bindEvents() {
                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
                this.canvas.addEventListener('mousemove', this.handleCanvasMouseMove.bind(this));
                window.addEventListener('resize', this.handleResize.bind(this));

                // Bind buttons using their IDs (safer than onclick in HTML)
                document.getElementById('resetRouteBtn').addEventListener('click', this.resetPlayerRoute.bind(this));
                document.getElementById('submitRouteBtn').addEventListener('click', this.submitPlayerRoute.bind(this));
                document.getElementById('showOptimalBtn').addEventListener('click', this.solveTSP.bind(this));
                document.getElementById('clearCitiesBtn').addEventListener('click', this.clearCities.bind(this));
                document.getElementById('randomCitiesBtn').addEventListener('click', () => this.generateRandomCities()); // Default count
                document.getElementById('random5CitiesBtn').addEventListener('click', () => this.generateRandomCities(5));
                document.getElementById('random8CitiesBtn').addEventListener('click', () => this.generateRandomCities(8));
                document.getElementById('random12CitiesBtn').addEventListener('click', () => this.generateRandomCities(12));
            }

            handleCanvasClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                let clickedCityIndex = -1;
                for (let i = 0; i < this.cities.length; i++) {
                    const city = this.cities[i];
                    const distance = Math.sqrt(Math.pow(mouseX - city.x, 2) + Math.pow(mouseY - city.y, 2));
                    if (distance <= 15) { // City radius for clicking
                        clickedCityIndex = i;
                        break;
                    }
                }

                if (clickedCityIndex !== -1) {
                    this.addCityToPlayerRoute(clickedCityIndex);
                } else {
                    this.addCity(mouseX, mouseY);
                }
            }

            handleCanvasMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                let hoverCityFound = false;

                for (let i = 0; i < this.cities.length; i++) {
                    const city = this.cities[i];
                    const distance = Math.sqrt(Math.pow(mouseX - city.x, 2) + Math.pow(mouseY - city.y, 2));
                    if (distance <= 15) {
                        if (this.currentHoverCity !== i) {
                            this.currentHoverCity = i;
                            this.draw(); // Redraw to show hover effect
                        }
                        hoverCityFound = true;
                        break;
                    }
                }
                if (!hoverCityFound && this.currentHoverCity !== null) {
                    this.currentHoverCity = null;
                    this.draw(); // Redraw to remove hover effect
                }
            }

            handleResize() {
                this.setupCanvas();
                this.draw();
            }

            // Function to draw different city "stickers"
            drawCityIcon(ctx, city, radius, alpha = 1) {
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = city.color || '#fff'; // Use predefined color or default
                
                // Add a pulsating glow for visited cities in player route
                if (this.playerRoute.includes(city.id) && city.animationProgress >= 1) {
                    const glowPulse = Math.sin(performance.now() / 200) * 2 + 3; // Pulsate between 1 and 5
                    ctx.shadowColor = city.color || '#00ffff';
                    ctx.shadowBlur = glowPulse;
                } else {
                    ctx.shadowBlur = 0;
                }

                switch (city.type) {
                    case 'planet':
                        ctx.beginPath();
                        ctx.arc(city.x, city.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        if (city.id % 3 === 0 && radius > 10) { // Add rings for larger planets
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.ellipse(city.x, city.y, radius * 1.5, radius * 0.5, Math.PI / 4, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                    case 'star':
                        // Simple 4-point star (diamond)
                        ctx.beginPath();
                        ctx.moveTo(city.x, city.y - radius);
                        ctx.lineTo(city.x + radius * 0.6, city.y);
                        ctx.lineTo(city.x, city.y + radius);
                        ctx.lineTo(city.x - radius * 0.6, city.y);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'nebula':
                        // A more abstract, cloud-like shape
                        ctx.beginPath();
                        ctx.arc(city.x, city.y, radius * 0.8, 0, Math.PI * 2);
                        ctx.arc(city.x + radius * 0.5, city.y - radius * 0.3, radius * 0.6, 0, Math.PI * 2);
                        ctx.arc(city.x - radius * 0.5, city.y + radius * 0.3, radius * 0.7, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    default: // Default to a simple circle
                        ctx.beginPath();
                        ctx.arc(city.x, city.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }

            addCity(x, y) {
                const cityTypes = ['planet', 'star', 'nebula'];
                const cityColors = ['#87ceeb', '#FFD700', '#FF6347', '#9370DB', '#7CFC00']; // Blue, Gold, Red, Purple, Green
                const newCity = { 
                    x, y, 
                    id: this.cities.length,
                    type: cityTypes[Math.floor(Math.random() * cityTypes.length)],
                    color: cityColors[Math.floor(Math.random() * cityColors.length)],
                    animationProgress: 0 // For warp-in animation
                };
                this.cities.push(newCity);
                this.resetGameState(); // Reset game state for new city addition
                
                this.animateCityIn(newCity); // Start warp-in animation
                this.updateStats();
            }

            animateCityIn(city) {
                const duration = 500; // ms
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    city.animationProgress = Math.min(1, elapsed / duration);
                    this.draw(); // Redraw canvas in each frame
                    if (city.animationProgress < 1) {
                        this.cityAnimationIds.set(city.id, requestAnimationFrame(animate));
                    } else {
                        this.cityAnimationIds.delete(city.id); // Animation complete
                    }
                };
                // Ensure no previous animation is running for this city
                if (this.cityAnimationIds.has(city.id)) {
                    cancelAnimationFrame(this.cityAnimationIds.get(city.id));
                }
                this.cityAnimationIds.set(city.id, requestAnimationFrame(animate));
            }

            addCityToPlayerRoute(cityIndex) {
                if (this.currentFuel <= 0) {
                    document.getElementById('gameFeedback').textContent = 'Mission Failed: Out of Fuel!';
                    document.getElementById('gameFeedback').style.color = '#e74c3c';
                    return;
                }
                
                const uniqueCitiesVisited = new Set(this.playerRoute).size;

                // If adding the very first city
                if (this.playerRoute.length === 0) {
                    this.playerRoute.push(cityIndex);
                    this.updateStats();
                    this.draw();
                    document.getElementById('gameFeedback').textContent = '';
                    document.getElementById('starRating').style.display = 'none';
                    return;
                }

                // Check for duplicate consecutive clicks (prevent adding same city twice in a row)
                if (this.playerRoute[this.playerRoute.length - 1] === cityIndex) {
                    // Allow clicking first city again to close loop if all unique cities visited
                    if (uniqueCitiesVisited === this.cities.length && this.playerRoute[0] === cityIndex) {
                        this.submitPlayerRoute(); // Submit if closing the loop
                    }
                    return; // Ignore if same city clicked consecutively (unless closing loop)
                }

                const prevCityIndex = this.playerRoute[this.playerRoute.length - 1];
                const distanceSegment = this.calculateDistance(this.cities[prevCityIndex], this.cities[cityIndex]);
                const fuelCost = distanceSegment * this.fuelConsumptionPerUnitDistance;

                if (this.currentFuel - fuelCost < 0) {
                    document.getElementById('gameFeedback').textContent = 'Not enough fuel for this jump! ‚ö†Ô∏è';
                    document.getElementById('gameFeedback').style.color = '#f39c12'; // Orange warning
                    return;
                }

                this.currentFuel -= fuelCost;
                this.playerRoute.push(cityIndex);
                this.playerDistance += distanceSegment;

                this.updateStats();
                this.animateLine(prevCityIndex, cityIndex);
                document.getElementById('gameFeedback').textContent = '';
                document.getElementById('starRating').style.display = 'none';
            }

            animateLine(fromCityIndex, toCityIndex) {
                const city1 = this.cities[fromCityIndex];
                const city2 = this.cities[toCityIndex];
                const duration = 300; // milliseconds
                const startTime = performance.now();

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(1, elapsed / duration);

                    this.draw(); // Clear and redraw everything

                    this.ctx.strokeStyle = '#00ffff'; // Player route color
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([]);
                    this.ctx.beginPath();

                    // Redraw all completed segments of player route
                    for (let i = 0; i < this.playerRoute.length - 1; i++) {
                        const p1 = this.cities[this.playerRoute[i]];
                        const p2 = this.cities[this.playerRoute[i+1]];
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                    }
                    this.ctx.stroke(); // Draw completed segments first

                    // Now draw the animating segment
                    this.ctx.beginPath();
                    this.ctx.moveTo(city1.x, city1.y);
                    const currentX = city1.x + (city2.x - city1.x) * progress;
                    const currentY = city1.y + (city2.y - city1.y) * progress;
                    this.ctx.lineTo(currentX, currentY);
                    this.ctx.stroke();


                    if (progress < 1) {
                        this.animationFrameId = requestAnimationFrame(animate);
                    } else {
                        this.animationFrameId = null; // Animation finished
                    }
                };
                // Cancel any ongoing line animations before starting a new one
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                this.animationFrameId = requestAnimationFrame(animate);
            }

            resetGameState() {
                // Cancel all ongoing animations
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                this.cityAnimationIds.forEach(id => cancelAnimationFrame(id));
                this.cityAnimationIds.clear();

                this.playerRoute = [];
                this.playerDistance = 0;
                this.currentFuel = this.maxFuel; // Reset fuel on game state clear/reset
                this.optimalRoute = [];
                this.optimalDistance = Infinity;
                document.getElementById('gameFeedback').textContent = '';
                document.getElementById('starRating').style.display = 'none';
                document.getElementById('gameFeedback').style.color = '#2ecc71'; // Reset feedback color
            }

            resetPlayerRoute() {
                this.resetGameState();
                this.draw(); // Redraw with cleared state
                this.updateStats();
            }

            submitPlayerRoute() {
                if (this.cities.length < 2) {
                    document.getElementById('gameFeedback').textContent = 'Need at least 2 cities to submit a route!';
                    document.getElementById('gameFeedback').style.color = '#f39c12';
                    return;
                }
                const uniqueCitiesVisited = new Set(this.playerRoute).size;
                if (uniqueCitiesVisited !== this.cities.length) {
                    document.getElementById('gameFeedback').textContent = 'Visit all cities before submitting!';
                    document.getElementById('gameFeedback').style.color = '#f39c12';
                    return;
                }
                // Ensure the route is a full cycle (ends back at start)
                if (this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1]) {
                     // Add the first city to close the loop for final calculation
                     this.playerRoute.push(this.playerRoute[0]);
                     this.playerDistance = this.calculateRouteDistance(this.playerRoute, false); // Calculate with added segment
                     
                     // Animate the closing line
                     this.animateLine(this.playerRoute[this.playerRoute.length - 2], this.playerRoute[this.playerRoute.length - 1]);
                     
                     // Delay solving and feedback until closing animation finishes
                     setTimeout(() => {
                        this.solveTSP(false); // Calculate optimal without redrawing it yet
                        this.updateStats();
                        this.giveFeedback();
                        this.draw(); // Final draw including player's full route
                     }, 350); // Slightly longer than line animation
                } else {
                    this.playerDistance = this.calculateRouteDistance(this.playerRoute, false); // Already closed
                    this.solveTSP(false); // Calculate optimal without redrawing it yet
                    this.updateStats();
                    this.draw(); // Redraw with final player route
                    this.giveFeedback();
                }
            }

            giveFeedback() {
                const feedbackDiv = document.getElementById('gameFeedback');
                const starRatingDiv = document.getElementById('starRating');
                starRatingDiv.style.display = 'block';

                if (this.optimalDistance === Infinity || this.optimalDistance === 0) {
                    feedbackDiv.textContent = 'Please show optimal route for comparison!';
                    feedbackDiv.style.color = '#f39c12';
                    starRatingDiv.textContent = '';
                    return;
                }
                if (this.currentFuel <= 0 && new Set(this.playerRoute).size < this.cities.length) {
                    feedbackDiv.textContent = 'Mission Failed: Out of Fuel! üí•';
                    starRatingDiv.textContent = 'üíÄ'; // Skull or similar for failure
                    feedbackDiv.style.color = '#e74c3c'; // Red for failure
                    return;
                }
                if (this.currentFuel <= 0 && new Set(this.playerRoute).size === this.cities.length && this.playerRoute[0] === this.playerRoute[this.playerRoute.length-1]) {
                    feedbackDiv.textContent = 'Mission Complete! But barely made it on fuel! ‚õΩ';
                    starRatingDiv.textContent = '‚úÖ';
                    feedbackDiv.style.color = '#f39c12'; // Yellow/orange for close call
                }

                // If not failed by fuel, then evaluate distance
                const playerRatio = this.playerDistance / this.optimalDistance;

                if (playerRatio <= 1.0001) { // Adding a small epsilon for floating point comparison
                    feedbackDiv.textContent = 'üöÄ Perfect Navigation! You found the optimal path!';
                    starRatingDiv.textContent = 'üåüüåüüåü';
                    feedbackDiv.style.color = '#2ecc71';
                } else if (playerRatio <= 1.15) { // Within 15% of optimal
                    feedbackDiv.textContent = '‚ú® Excellent Pilot! A near-optimal path!';
                    starRatingDiv.textContent = 'üåüüåü';
                    feedbackDiv.style.color = '#2ecc71';
                } else if (playerRatio <= 1.30) { // Within 30% of optimal
                    feedbackDiv.textContent = '‚≠ê Good Effort! You\'re getting closer!';
                    starRatingDiv.textContent = 'üåü';
                    feedbackDiv.style.color = '#2ecc71';
                } else {
                    feedbackDiv.textContent = 'Keep Exploring! Try to find a shorter route.';
                    starRatingDiv.textContent = 'üòî';
                    feedbackDiv.style.color = '#f39c12';
                }
            }

            clearCities() {
                this.resetGameState(); // Resets everything including fuel and animations
                this.cities = [];
                this.updateStats();
                this.draw();
            }

            generateRandomCities(count = 8) {
                this.clearCities(); // Clear existing cities and reset state
                const margin = 50;
                const width = this.canvas.offsetWidth - 2 * margin;
                const height = this.canvas.offsetHeight - 2 * margin;

                const cityTypes = ['planet', 'star', 'nebula'];
                const cityColors = ['#87ceeb', '#FFD700', '#FF6347', '#9370DB', '#7CFC00'];

                let newCities = [];
                for (let i = 0; i < count; i++) {
                    // Ensure cities are not too close to each other
                    let x, y, tooClose;
                    let attempts = 0;
                    do {
                        x = margin + Math.random() * width;
                        y = margin + Math.random() * height;
                        tooClose = false;
                        for (let j = 0; j < newCities.length; j++) {
                            const existingCity = newCities[j];
                            const distance = Math.sqrt(Math.pow(x - existingCity.x, 2) + Math.pow(y - existingCity.y, 2));
                            if (distance < 50) { // Minimum distance between cities
                                tooClose = true;
                                break;
                            }
                        }
                        attempts++;
                    } while (tooClose && attempts < 100); // Prevent infinite loop on small canvas
                    
                    newCities.push({ 
                        x, y, 
                        id: i,
                        type: cityTypes[Math.floor(Math.random() * cityTypes.length)],
                        color: cityColors[Math.floor(Math.random() * cityColors.length)],
                        animationProgress: 0
                    });
                }
                this.cities = newCities;
                this.cities.forEach(city => this.animateCityIn(city)); // Animate all in
                this.updateStats();
            }

            calculateDistance(city1, city2) {
                const dx = city1.x - city2.x;
                const dy = city1.y - city2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            calculateRouteDistance(routeIndices, loop = true) {
                if (routeIndices.length < 2) return 0;
                
                let distance = 0;
                for (let i = 0; i < routeIndices.length - 1; i++) {
                    distance += this.calculateDistance(this.cities[routeIndices[i]], this.cities[routeIndices[i + 1]]);
                }
                // If looping, add distance back to start
                if (loop && routeIndices.length > 0) {
                    distance += this.calculateDistance(this.cities[routeIndices[routeIndices.length - 1]], this.cities[routeIndices[0]]);
                }
                return distance;
            }

            // Nearest Neighbor Heuristic (Fast, but not always optimal)
            nearestNeighborTSP() {
                if (this.cities.length < 2) return [];

                const unvisited = new Set(Array.from({ length: this.cities.length }, (_, i) => i));
                const route = [];
                let currentCityIndex = 0; // Start at city 0

                route.push(currentCityIndex);
                unvisited.delete(currentCityIndex);

                while (unvisited.size > 0) {
                    let nearest = -1;
                    let nearestDistance = Infinity;

                    for (const cityIndex of unvisited) {
                        const distance = this.calculateDistance(this.cities[currentCityIndex], this.cities[cityIndex]);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearest = cityIndex;
                        }
                    }
                    route.push(nearest);
                    unvisited.delete(nearest);
                    currentCityIndex = nearest;
                }
                return route;
            }
            
            // Brute Force TSP (Guarantees optimal, but extremely slow for N > ~10)
            bruteForceTSP() {
                const numCities = this.cities.length;
                if (numCities < 2) return [];
                // IMPORTANT: Limit brute force to prevent browser freezing
                if (numCities > 8) { 
                    console.warn(`Brute force is too slow for ${numCities} cities. Using Nearest Neighbor approximation.`);
                    return this.nearestNeighborTSP();
                }

                let smallestDistance = Infinity;
                let bestPermutation = [];

                const swap = (arr, i, j) => {
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                };

                const permute = (arr, l, r) => {
                    if (l === r) {
                        const currentDistance = this.calculateRouteDistance(arr, true);
                        if (currentDistance < smallestDistance) {
                            smallestDistance = currentDistance;
                            bestPermutation = [...arr];
                        }
                    } else {
                        for (let i = l; i <= r; i++) {
                            swap(arr, l, i);
                            permute(arr, l + 1, r);
                            swap(arr, l, i); // Backtrack
                        }
                    }
                };

                const initialPermutation = Array.from({ length: numCities }, (_, i) => i);
                permute(initialPermutation, 0, numCities - 1);
                
                return bestPermutation;
            }

            solveTSP(showRouteImmediately = true) {
                if (this.cities.length < 2) {
                    document.getElementById('gameFeedback').textContent = 'Add more cities to find an optimal route!';
                    document.getElementById('gameFeedback').style.color = '#f39c12';
                    return;
                }
                document.getElementById('gameFeedback').textContent = 'Calculating optimal route...';
                document.getElementById('gameFeedback').style.color = '#00ffff';

                const route = this.cities.length <= 8 ? this.bruteForceTSP() : this.nearestNeighborTSP();
                
                this.optimalDistance = this.calculateRouteDistance(route, true);
                this.optimalRoute = route;

                this.updateStats();
                if(showRouteImmediately) {
                    this.draw();
                    document.getElementById('gameFeedback').textContent = 'Optimal route displayed!';
                    document.getElementById('gameFeedback').style.color = '#2ecc71';
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw optimal route (if exists)
                if (this.optimalRoute.length > 1 && this.optimalDistance < Infinity) {
                    this.ctx.strokeStyle = '#FFD700'; // Gold color for optimal
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([8, 8]); // Dashed line for optimal
                    this.ctx.beginPath();
                    for (let i = 0; i < this.optimalRoute.length; i++) {
                        const city = this.cities[this.optimalRoute[i]];
                        if (i === 0) {
                            this.ctx.moveTo(city.x, city.y);
                        } else {
                            this.ctx.lineTo(city.x, city.y);
                        }
                    }
                    if (this.optimalRoute.length > 0) {
                        const firstCity = this.cities[this.optimalRoute[0]];
                        this.ctx.lineTo(firstCity.x, firstCity.y); // Close loop
                    }
                    this.ctx.stroke();
                }
                
                // Draw player's current route (non-animating parts)
                if (this.playerRoute.length > 1) {
                    this.ctx.strokeStyle = '#00ffff'; // Cyan for player's route
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([]); // Solid line for player
                    this.ctx.beginPath();
                    for (let i = 0; i < this.playerRoute.length; i++) {
                        const city = this.cities[this.playerRoute[i]];
                        if (i === 0) {
                            this.ctx.moveTo(city.x, city.y);
                        } else {
                            this.ctx.lineTo(city.x, city.y);
                        }
                    }
                    // If all unique cities visited and not yet explicitly closed, draw a potential closing line
                    const uniqueCitiesVisited = new Set(this.playerRoute).size;
                    if (uniqueCitiesVisited === this.cities.length && this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1]) {
                         const firstCity = this.cities[this.playerRoute[0]];
                         this.ctx.lineTo(firstCity.x, firstCity.y);
                    }
                    this.ctx.stroke();

                    // Draw direction arrows for player route
                    this.drawDirectionArrows(this.playerRoute, '#00ffff');
                }

                // Draw cities
                this.cities.forEach((city, index) => {
                    // City glow and animation
                    const baseRadius = 15;
                    const animatedRadius = baseRadius * city.animationProgress;
                    const animatedAlpha = city.animationProgress;

                    const radius = (this.currentHoverCity === index) ? (animatedRadius * 1.2) : animatedRadius;
                    
                    const glowGradient = this.ctx.createRadialGradient(city.x, city.y, 0, city.x, city.y, radius + 5);
                    glowGradient.addColorStop(0, `rgba(255, 255, 255, ${animatedAlpha * 0.9})`);
                    glowGradient.addColorStop(0.7, (this.currentHoverCity === index) ? `rgba(0, 255, 255, ${animatedAlpha})` : `rgba(135, 206, 235, ${animatedAlpha})`);
                    glowGradient.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = glowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(city.x, city.y, radius + 5, 0, 2 * Math.PI); // Larger outer glow
                    this.ctx.fill();

                    // Draw the themed city icon
                    this.drawCityIcon(this.ctx, city, radius, animatedAlpha);
                    
                    // City number (only if visible enough)
                    if (city.animationProgress > 0.8) {
                        this.ctx.fillStyle = '#000';
                        this.ctx.font = 'bold 13px Orbitron'; /* Font for city numbers */
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText((index + 1).toString(), city.x, city.y);
                    }
                });

                // Request animation frame for continuous hover effects/visited city glow
                if (this.currentHoverCity !== null || this.playerRoute.some(id => this.cities[id].animationProgress >= 1)) {
                    requestAnimationFrame(this.draw.bind(this));
                }
            }

            drawDirectionArrows(routeIndices, color) {
                if (routeIndices.length < 2) return;

                this.ctx.fillStyle = color;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;

                const segmentsToDraw = routeIndices.length - 1;

                for (let i = 0; i < segmentsToDraw; i++) {
                    const currentCity = this.cities[routeIndices[i]];
                    const nextCity = this.cities[routeIndices[i + 1]];
                    
                    const dx = nextCity.x - currentCity.x;
                    const dy = nextCity.y - currentCity.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 30) { // Only draw arrow if segment is long enough
                        const midX = currentCity.x + dx * 0.5; // Midpoint for arrow
                        const midY = currentCity.y + dy * 0.5;

                        const angle = Math.atan2(dy, dx);
                        const arrowLength = 10;
                        const arrowAngle = 0.5; // Angle of arrow head "wings"

                        this.ctx.beginPath();
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle - arrowAngle),
                            midY - arrowLength * Math.sin(angle - arrowAngle)
                        );
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle + arrowAngle),
                            midY - arrowLength * Math.sin(angle + arrowAngle)
                        );
                        this.ctx.stroke();
                    }
                }
                // Draw closing arrow if applicable and not already drawn
                const uniqueCitiesVisited = new Set(routeIndices).size;
                if (uniqueCitiesVisited === this.cities.length && routeIndices[0] === routeIndices[routeIndices.length - 1] && routeIndices.length > this.cities.length) {
                    const currentCity = this.cities[routeIndices[routeIndices.length - 2]]; // Second to last, which is the last unique city
                    const nextCity = this.cities[routeIndices[routeIndices.length - 1]]; // The closing city (same as first)

                    const dx = nextCity.x - currentCity.x;
                    const dy = nextCity.y - currentCity.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 30) {
                        const midX = currentCity.x + dx * 0.5;
                        const midY = currentCity.y + dy * 0.5;

                        const angle = Math.atan2(dy, dx);
                        const arrowLength = 10;
                        const arrowAngle = 0.5;

                        this.ctx.beginPath();
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle - arrowAngle),
                            midY - arrowLength * Math.sin(angle - arrowAngle)
                        );
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle + arrowAngle),
                            midY - arrowLength * Math.sin(angle + arrowAngle)
                        );
                        this.ctx.stroke();
                    }
                }
            }

            updateStats() {
                document.getElementById('cityCount').textContent = this.cities.length;
                document.getElementById('playerDistance').textContent =
                    this.playerDistance > 0 ? Math.round(this.playerDistance) : '0';
                document.getElementById('bestDistance').textContent =
                    this.optimalDistance < Infinity ? Math.round(this.optimalDistance) : '-';
                
                // Update goal message
                const goalMessageElement = document.getElementById('goalMessage');
                const uniqueCitiesVisited = new Set(this.playerRoute).size;

                if (this.cities.length === 0) {
                    goalMessageElement.textContent = 'Place cities!';
                    goalMessageElement.style.color = '#00ffff';
                } else if (this.currentFuel <= 0 && uniqueCitiesVisited < this.cities.length) {
                    goalMessageElement.textContent = 'Out of fuel!';
                    goalMessageElement.style.color = '#e74c3c'; // Red for fuel failure
                } else if (this.playerRoute.length === 0) {
                    goalMessageElement.textContent = 'Start plotting!';
                    goalMessageElement.style.color = '#00ffff';
                } else if (uniqueCitiesVisited < this.cities.length) {
                    goalMessageElement.textContent = `Visit ${this.cities.length - uniqueCitiesVisited} more!`;
                    goalMessageElement.style.color = '#00ffff';
                } else if (this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1] && uniqueCitiesVisited === this.cities.length) {
                    goalMessageElement.textContent = 'Close the loop!';
                    goalMessageElement.style.color = '#00ffff';
                } else {
                    goalMessageElement.textContent = 'Submit your path!';
                    goalMessageElement.style.color = '#00ffff';
                }

                // Update Fuel Gauge
                const fuelGauge = document.getElementById('fuelGauge');
                const fuelLabel = document.getElementById('fuelLabel');
                const fuelPercentage = (this.currentFuel / this.maxFuel) * 100;
                fuelGauge.style.width = `${Math.max(0, fuelPercentage)}%`;
                fuelLabel.textContent = `${Math.round(this.currentFuel)} / ${this.maxFuel} units`;

                if (fuelPercentage <= 20) {
                    fuelGauge.classList.add('empty');
                } else {
                    fuelGauge.classList.remove('empty');
                }
            }
        }

        // --- Initialize everything when page loads ---
        document.addEventListener('DOMContentLoaded', function () {
            createStars();
            window.tspGame = new TSPGame();
            
            // Initial animation for sections
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1 }); // Trigger when 10% of element is visible

            document.querySelectorAll('.phase').forEach(phase => {
                observer.observe(phase);
            });

            // Start continuous draw for hover and visited city effects
            function animateCanvas() {
                if (window.tspGame) {
                    window.tspGame.draw();
                }
                requestAnimationFrame(animateCanvas);
            }
            animateCanvas();
        });
    </script>
</body>
</html>
