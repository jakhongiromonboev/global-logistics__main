<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP Navigator - The Cosmic Challenge</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Styles --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif; /* Futuristic font */
            background: linear-gradient(135deg, #0c0c2e 0%, #1a1a3a 50%, #2d2d5f 100%);
            color: white;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* --- Starry Background --- */
        #stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle linear infinite;
            box-shadow: 0 0 5px white; /* Add a subtle glow */
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        /* --- Main Container --- */
        .container {
            position: relative;
            z-index: 10;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        /* --- Header --- */
        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.08); /* Slightly more opaque */
            backdrop-filter: blur(12px); /* Stronger blur */
            border-radius: 20px; /* More rounded */
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15); /* Thicker border */
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.3); /* Blueish glow */
            animation: fadeInHeader 1s ease-out; /* New animation for header */
        }

        .header h1 {
            font-size: 3em; /* Larger title */
            margin-bottom: 12px;
            color: #87ceeb; /* Sky blue */
            text-shadow: 0 0 25px rgba(135, 206, 235, 0.8); /* Stronger glow */
            letter-spacing: 2px;
        }

        .header p {
            font-size: 1.1em;
            color: #c0c0c0;
        }

        /* --- Game Area Layout --- */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 320px; /* Slightly wider control panel */
            gap: 25px; /* Larger gap */
        }

        /* --- Canvas Container --- */
        .canvas-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        #gameCanvas {
            width: 100%;
            height: 550px; /* Taller canvas */
            background: rgba(0, 0, 0, 0.4); /* Darker background */
            border-radius: 15px;
            cursor: crosshair;
            border: 2px solid rgba(255, 255, 255, 0.25);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5); /* Inner shadow */
        }

        /* --- Control Panel --- */
        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            height: fit-content;
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        .control-section {
            margin-bottom: 25px; /* Larger margin */
            padding-bottom: 25px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2); /* Dashed border */
        }

        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .control-section h3 {
            margin-bottom: 18px;
            color: #87ceeb;
            text-shadow: 0 0 15px rgba(135, 206, 235, 0.7);
            font-size: 1.3em;
            letter-spacing: 1px;
        }

        /* --- Buttons --- */
        .btn {
            width: 100%;
            padding: 14px; /* Larger padding */
            margin: 10px 0; /* Larger margin */
            border: none;
            border-radius: 10px; /* More rounded */
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Stronger button shadow */
            text-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        .btn-primary {
            background: linear-gradient(45deg, #4a90e2, #7bb3f0); /* Blue gradient */
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(45deg, #357abd, #5a9bd4);
            transform: translateY(-3px) scale(1.02); /* More pronounced hover */
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #e74c3c, #f39c12); /* Orange/Red gradient */
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #c0392b, #d68910);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.6);
        }

        .btn-success {
            background: linear-gradient(45deg, #27ae60, #2ecc71); /* Green gradient */
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(45deg, #1e8449, #25a25a);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.6);
        }

        /* --- Info Display --- */
        .info-display {
            background: rgba(0, 0, 0, 0.5); /* Darker, more solid background */
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 5px solid #00ffff; /* Cyan accent */
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.3); /* Inner cyan glow */
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 15px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.1); /* Subtle separator */
            padding-bottom: 5px;
        }
        .info-item:last-child { border-bottom: none; }


        .info-label {
            color: #87ceeb;
            font-weight: normal;
        }

        .info-value {
            font-weight: bold;
            color: #00ffff; /* Cyan for values */
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }

        /* --- Fuel Gauge --- */
        .fuel-gauge-container {
            width: 100%;
            height: 25px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            overflow: hidden;
            margin-top: 10px;
            position: relative;
            box-shadow: inset 0 0 5px rgba(0, 255, 255, 0.5);
        }

        #fuelGauge {
            height: 100%;
            width: 100%; /* Default to full */
            background: linear-gradient(90deg, #e74c3c, #f39c12, #2ecc71); /* Red to Green */
            border-radius: 12px;
            transition: width 0.3s ease-out;
            transform-origin: left;
        }
        #fuelGauge.empty {
            background: #e74c3c;
        }
        #fuelLabel {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 25px;
            font-size: 12px;
            color: white;
            text-shadow: 0 0 3px black;
        }


        /* --- Animations --- */
        .phase {
            opacity: 0;
            transform: translateY(30px); /* Larger initial translation */
            transition: opacity 0.8s ease-out, transform 0.8s ease-out; /* Slower, smoother animation */
        }

        .phase.visible {
            opacity: 1;
            transform: translateY(0);
        }

        @keyframes fadeInHeader {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Instructions --- */
        .instructions {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 25px;
            margin-top: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.2);
        }

        .instructions h3 {
            color: #87ceeb;
            margin-bottom: 18px;
            text-shadow: 0 0 15px rgba(135, 206, 235, 0.7);
            font-size: 1.3em;
            letter-spacing: 1px;
        }

        .instructions ul {
            list-style: none;
            padding-left: 0;
        }

        .instructions li {
            margin: 10px 0;
            padding-left: 25px; /* More space for bullet */
            position: relative;
            font-size: 0.95em;
            color: #c0c0c0;
        }

        .instructions li:before {
            content: "üöÄ"; /* More thematic bullet */
            position: absolute;
            left: 0;
            color: #00ffff; /* Cyan rocket */
            font-size: 1.2em;
        }

        /* --- Scoreboard/Game Feedback --- */
        #gameFeedback {
            text-align: center;
            margin-top: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #2ecc71; /* Green for success */
            text-shadow: 0 0 15px rgba(46, 204, 113, 0.7);
            min-height: 30px; /* Reserve space */
        }

        #starRating {
            margin-top: 10px;
            font-size: 2.5em;
            color: gold;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            display: none; /* Hidden by default */
        }

        /* --- Responsive Design --- */
        @media (max-width: 992px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 576px) {
            .header h1 {
                font-size: 2em;
            }
            .container {
                padding: 10px;
            }
            .control-panel, .canvas-container, .header, .instructions {
                padding: 15px;
            }
            .btn {
                padding: 10px;
                font-size: 13px;
            }
            .info-item {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div id="stars"></div>
    
    <div class="container">
        <div class="header phase">
            <h1>üåü TSP Navigator: The Cosmic Challenge üåü</h1>
            <p>Plot your flight path and find the shortest route through all stellar cities!</p>
        </div>

        <div class="game-area phase">
            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>
            
            <div class="control-panel">
                <div class="control-section">
                    <h3>üéÆ Navigation Controls</h3>
                    <button class="btn btn-primary" onclick="window.tspGame.resetPlayerRoute()">Reset My Route</button>
                    <button class="btn btn-success" onclick="window.tspGame.submitPlayerRoute()">Submit My Route</button>
                    <button class="btn btn-secondary" onclick="window.tspGame.solveTSP()">Show Optimal Route</button>
                </div>

                <div class="control-section">
                    <h3>üåå Stellar Map</h3>
                    <button class="btn btn-primary" onclick="window.tspGame.clearCities()">Clear All Cities</button>
                    <button class="btn btn-secondary" onclick="window.tspGame.generateRandomCities()">New Random Cities</button>
                    <div style="display: flex; gap: 5px; margin-top: 10px;">
                        <button class="btn btn-primary" style="flex: 1;" onclick="window.tspGame.generateRandomCities(5)">5 Stars</button>
                        <button class="btn btn-primary" style="flex: 1;" onclick="window.tspGame.generateRandomCities(8)">8 Stars</button>
                        <button class="btn btn-primary" style="flex: 1;" onclick="window.tspGame.generateRandomCities(12)">12 Stars</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üìä Mission Briefing</h3>
                    <div class="info-display">
                        <div class="info-item">
                            <span class="info-label">Cities Discovered:</span>
                            <span class="info-value" id="cityCount">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">My Path Length:</span>
                            <span class="info-value" id="playerDistance">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Optimal Path:</span>
                            <span class="info-value" id="bestDistance">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Current Goal:</span>
                            <span class="info-value" id="goalMessage">Plot a path!</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Fuel Remaining:</span>
                            <div class="fuel-gauge-container">
                                <div id="fuelGauge"></div>
                                <span id="fuelLabel"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gameFeedback"></div>
        <div id="starRating"></div>

        <div class="instructions phase">
            <h3>üéØ Mission Objectives</h3>
            <ul>
                <li>üöÄ **Click on the nebula** to establish new star cities.</li>
                <li>‚≠ê **Click on cities in sequence** to plot your navigation route. Click the first city again to complete the loop.</li>
                <li>‚õΩ **Watch your fuel!** Each jump consumes fuel. Reach all cities and close the loop before running out!</li>
                <li>‚úÖ **"Submit My Route"** to see how your path compares to the supercomputer's optimal solution.</li>
                <li>üß† **"Show Optimal Route"** reveals the shortest path found by the algorithm.</li>
                <li>üîÑ Use **"Reset My Route"** to clear your path and try again.</li>
                <li>‚ú® Earn **star ratings** based on how close your path is to the optimal!</li>
            </ul>
        </div>
    </div>

    <script>
        // --- Animated Stars Background ---
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const numStars = 200; // More stars for a richer background
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = (Math.random() * 3 + 1) + 'px'; // Vary star size
                star.style.animationDelay = Math.random() * 5 + 's';
                star.style.animationDuration = (Math.random() * 4 + 3) + 's'; // Vary twinkle speed
                starsContainer.appendChild(star);
            }
        }

        // --- TSP Game Logic ---
        class TSPGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cities = [];
                this.playerRoute = []; // Stores indices of cities in player's path
                this.optimalRoute = [];
                this.optimalDistance = Infinity;
                this.playerDistance = 0;
                this.currentHoverCity = null; // For hover effect on cities
                this.animationFrameId = null; // To manage animations

                // Fuel System
                this.maxFuel = 1000;
                this.currentFuel = this.maxFuel;
                this.fuelConsumptionPerUnitDistance = 1; // Adjust this value for difficulty

                this.setupCanvas();
                this.bindEvents();
                this.updateStats();
                this.draw();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width *= dpr;
                this.canvas.height *= dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }

            bindEvents() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Check if clicked on an existing city
                    let clickedCityIndex = -1;
                    for (let i = 0; i < this.cities.length; i++) {
                        const city = this.cities[i];
                        const distance = Math.sqrt(Math.pow(mouseX - city.x, 2) + Math.pow(mouseY - city.y, 2));
                        if (distance <= 15) { // City radius for clicking
                            clickedCityIndex = i;
                            break;
                        }
                    }

                    if (clickedCityIndex !== -1) {
                        this.addCityToPlayerRoute(clickedCityIndex);
                    } else {
                        // Add new city if not clicking existing one
                        this.addCity(mouseX, mouseY);
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    let hoverCityFound = false;

                    for (let i = 0; i < this.cities.length; i++) {
                        const city = this.cities[i];
                        const distance = Math.sqrt(Math.pow(mouseX - city.x, 2) + Math.pow(mouseY - city.y, 2));
                        if (distance <= 15) {
                            if (this.currentHoverCity !== i) {
                                this.currentHoverCity = i;
                                this.draw(); // Redraw to show hover effect
                            }
                            hoverCityFound = true;
                            break;
                        }
                    }
                    if (!hoverCityFound && this.currentHoverCity !== null) {
                        this.currentHoverCity = null;
                        this.draw(); // Redraw to remove hover effect
                    }
                });

                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.draw();
                });
            }

            // Function to draw different city "stickers"
            drawCityIcon(ctx, city, radius, alpha = 1) {
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = city.color || '#fff'; // Use predefined color or default
                
                // Draw different shapes based on city type
                switch (city.type) {
                    case 'planet':
                        ctx.beginPath();
                        ctx.arc(city.x, city.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        // Add a simple ring for a 'gas giant' effect
                        if (city.id % 3 === 0) {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.ellipse(city.x, city.y, radius * 1.5, radius * 0.5, Math.PI / 4, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                    case 'star':
                        // Simple star shape (e.g., a diamond or cross for now)
                        ctx.beginPath();
                        ctx.moveTo(city.x, city.y - radius);
                        ctx.lineTo(city.x + radius * 0.6, city.y);
                        ctx.lineTo(city.x, city.y + radius);
                        ctx.lineTo(city.x - radius * 0.6, city.y);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'nebula':
                        // A more abstract, cloud-like shape
                        ctx.beginPath();
                        ctx.arc(city.x, city.y, radius * 0.8, 0, Math.PI * 2);
                        ctx.arc(city.x + radius * 0.5, city.y - radius * 0.3, radius * 0.6, 0, Math.PI * 2);
                        ctx.arc(city.x - radius * 0.5, city.y + radius * 0.3, radius * 0.7, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    default: // Default to a simple circle
                        ctx.beginPath();
                        ctx.arc(city.x, city.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }

            addCity(x, y) {
                const cityTypes = ['planet', 'star', 'nebula'];
                const cityColors = ['#87ceeb', '#FFD700', '#FF6347', '#9370DB', '#7CFC00']; // Blue, Gold, Red, Purple, Green
                const newCity = { 
                    x, y, 
                    id: this.cities.length,
                    type: cityTypes[Math.floor(Math.random() * cityTypes.length)],
                    color: cityColors[Math.floor(Math.random() * cityColors.length)],
                    animationProgress: 0 // For warp-in animation
                };
                this.cities.push(newCity);
                this.resetPlayerRoute(); // Reset player route on new city
                this.optimalRoute = []; // Clear optimal route
                this.optimalDistance = Infinity; // Reset optimal distance
                this.currentFuel = this.maxFuel; // Refill fuel on new game state
                document.getElementById('gameFeedback').textContent = '';
                document.getElementById('starRating').style.display = 'none';

                this.animateCityIn(newCity); // Start warp-in animation
                this.updateStats();
            }

            animateCityIn(city) {
                const duration = 500; // ms
                const startTime = performance.now();
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    city.animationProgress = Math.min(1, elapsed / duration);
                    this.draw(); // Redraw canvas
                    if (city.animationProgress < 1) {
                        this.animationFrameId = requestAnimationFrame(animate);
                    }
                };
                this.animationFrameId = requestAnimationFrame(animate);
            }

            addCityToPlayerRoute(cityIndex) {
                if (this.currentFuel <= 0) {
                    document.getElementById('gameFeedback').textContent = 'Mission Failed: Out of Fuel!';
                    return;
                }
                
                const currentCityCount = this.playerRoute.filter((v, i, a) => a.indexOf(v) === i).length;

                // If adding the very first city
                if (this.playerRoute.length === 0) {
                    this.playerRoute.push(cityIndex);
                    this.updateStats();
                    this.draw();
                    document.getElementById('gameFeedback').textContent = '';
                    document.getElementById('starRating').style.display = 'none';
                    return;
                }

                // Check for duplicate consecutive clicks (prevent adding same city twice in a row)
                if (this.playerRoute[this.playerRoute.length - 1] === cityIndex) {
                    // Allow clicking first city again to close loop if all unique cities visited
                    const uniqueCitiesVisited = new Set(this.playerRoute).size;
                    if (uniqueCitiesVisited === this.cities.length && this.playerRoute[0] === cityIndex) {
                        this.submitPlayerRoute(); // Submit if closing the loop
                    }
                    return;
                }

                const prevCityIndex = this.playerRoute[this.playerRoute.length - 1];
                const distanceSegment = this.calculateDistance(this.cities[prevCityIndex], this.cities[cityIndex]);
                const fuelCost = distanceSegment * this.fuelConsumptionPerUnitDistance;

                if (this.currentFuel - fuelCost < 0) {
                    document.getElementById('gameFeedback').textContent = 'Not enough fuel for this jump!';
                    return;
                }

                this.currentFuel -= fuelCost;
                this.playerRoute.push(cityIndex);
                this.playerDistance += distanceSegment;

                this.updateStats();
                // Animate the line drawing
                this.animateLine(prevCityIndex, cityIndex, () => {
                    this.draw(); // Redraw after animation
                });
                document.getElementById('gameFeedback').textContent = '';
                document.getElementById('starRating').style.display = 'none';
            }

            animateLine(fromCityIndex, toCityIndex, callback) {
                const city1 = this.cities[fromCityIndex];
                const city2 = this.cities[toCityIndex];
                const duration = 300; // milliseconds
                const startTime = performance.now();

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(1, elapsed / duration);

                    this.draw(); // Clear and redraw everything
                    this.ctx.strokeStyle = '#00ffff'; // Player route color
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([]);
                    this.ctx.beginPath();

                    // Redraw previous segments
                    for (let i = 0; i < this.playerRoute.length - 1; i++) {
                        const p1 = this.cities[this.playerRoute[i]];
                        const p2 = this.cities[this.playerRoute[i+1]];
                        if (i === 0) this.ctx.moveTo(p1.x, p1.y);
                        else this.ctx.lineTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                    }

                    // Draw the animating segment
                    const currentX = city1.x + (city2.x - city1.x) * progress;
                    const currentY = city1.y + (city2.y - city1.y) * progress;
                    
                    if (this.playerRoute.length === 1) { // If it's the very first segment
                         this.ctx.moveTo(city1.x, city1.y);
                    }
                    this.ctx.lineTo(currentX, currentY);
                    this.ctx.stroke();

                    if (progress < 1) {
                        this.animationFrameId = requestAnimationFrame(animate);
                    } else {
                        if (callback) callback();
                    }
                };
                // Cancel any ongoing line animations before starting a new one
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                this.animationFrameId = requestAnimationFrame(animate);
            }

            resetPlayerRoute() {
                // Cancel any ongoing animations before resetting
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }

                this.playerRoute = [];
                this.playerDistance = 0;
                this.currentFuel = this.maxFuel; // Reset fuel on route clear
                document.getElementById('gameFeedback').textContent = '';
                document.getElementById('starRating').style.display = 'none';
                this.updateStats();
                this.draw();
            }

            submitPlayerRoute() {
                if (this.cities.length < 2) {
                    document.getElementById('gameFeedback').textContent = 'Need at least 2 cities to submit a route!';
                    return;
                }
                const uniqueCitiesVisited = new Set(this.playerRoute).size;
                if (uniqueCitiesVisited !== this.cities.length) {
                    document.getElementById('gameFeedback').textContent = 'Visit all cities before submitting!';
                    return;
                }
                // Ensure the route is a full cycle (ends back at start)
                if (this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1]) {
                     // Add the first city to close the loop for final calculation
                     this.playerRoute.push(this.playerRoute[0]);
                     this.playerDistance = this.calculateRouteDistance(this.playerRoute, true);
                     // Animate the closing line
                     this.animateLine(this.playerRoute[this.playerRoute.length - 2], this.playerRoute[this.playerRoute.length - 1], () => {
                        this.draw(); // Redraw after animation
                        this.solveTSP(); // Immediately calculate optimal route for comparison
                        this.updateStats();
                        this.giveFeedback();
                     });
                } else {
                    this.playerDistance = this.calculateRouteDistance(this.playerRoute, true);
                    this.solveTSP(); // Immediately calculate optimal route for comparison
                    this.updateStats();
                    this.draw(); // Redraw with final player route
                    this.giveFeedback();
                }
                
            }

            giveFeedback() {
                const feedbackDiv = document.getElementById('gameFeedback');
                const starRatingDiv = document.getElementById('starRating');
                starRatingDiv.style.display = 'block';

                if (this.optimalDistance === Infinity || this.optimalDistance === 0) {
                    feedbackDiv.textContent = 'Please solve for optimal route first.';
                    starRatingDiv.textContent = '';
                    return;
                }
                if (this.currentFuel <= 0 && this.playerRoute.filter((v, i, a) => a.indexOf(v) === i).length < this.cities.length) {
                    feedbackDiv.textContent = 'Mission Failed: Out of Fuel! üí•';
                    starRatingDiv.textContent = 'üíÄ'; // Skull or similar for failure
                    feedbackDiv.style.color = '#e74c3c'; // Red for failure
                    return;
                }

                feedbackDiv.style.color = '#2ecc71'; // Default success color

                const playerRatio = this.playerDistance / this.optimalDistance;

                if (playerRatio <= 1.0) {
                    feedbackDiv.textContent = 'üöÄ Perfect Navigation! You found the optimal path!';
                    starRatingDiv.textContent = 'üåüüåüüåü';
                } else if (playerRatio <= 1.15) { // Within 15% of optimal
                    feedbackDiv.textContent = '‚ú® Excellent Pilot! A near-optimal path!';
                    starRatingDiv.textContent = 'üåüüåü';
                } else if (playerRatio <= 1.30) { // Within 30% of optimal
                    feedbackDiv.textContent = '‚≠ê Good Effort! You\'re getting closer!';
                    starRatingDiv.textContent = 'üåü';
                } else {
                    feedbackDiv.textContent = 'Keep Exploring! Try to find a shorter route.';
                    starRatingDiv.textContent = 'üòî';
                }
            }


            clearCities() {
                // Cancel any ongoing animations before clearing
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                this.cities = [];
                this.resetPlayerRoute(); // This also resets fuel
                this.optimalRoute = [];
                this.optimalDistance = Infinity;
                document.getElementById('gameFeedback').textContent = '';
                document.getElementById('starRating').style.display = 'none';
                this.updateStats();
                this.draw();
            }

            generateRandomCities(count = 8) {
                this.clearCities();
                const margin = 50;
                const width = this.canvas.offsetWidth - 2 * margin;
                const height = this.canvas.offsetHeight - 2 * margin;

                const cityTypes = ['planet', 'star', 'nebula'];
                const cityColors = ['#87ceeb', '#FFD700', '#FF6347', '#9370DB', '#7CFC00'];

                let newCities = [];
                for (let i = 0; i < count; i++) {
                    const x = margin + Math.random() * width;
                    const y = margin + Math.random() * height;
                    newCities.push({ 
                        x, y, 
                        id: i,
                        type: cityTypes[Math.floor(Math.random() * cityTypes.length)],
                        color: cityColors[Math.floor(Math.random() * cityColors.length)],
                        animationProgress: 0
                    });
                }
                this.cities = newCities; // Add all cities at once
                this.cities.forEach(city => this.animateCityIn(city)); // Animate all in
                this.updateStats();
            }

            calculateDistance(city1, city2) {
                const dx = city1.x - city2.x;
                const dy = city1.y - city2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            calculateRouteDistance(routeIndices, loop = true) {
                if (routeIndices.length < 2) return 0;
                
                let distance = 0;
                for (let i = 0; i < routeIndices.length - 1; i++) {
                    distance += this.calculateDistance(this.cities[routeIndices[i]], this.cities[routeIndices[i + 1]]);
                }
                // If looping, add distance back to start
                if (loop && routeIndices.length > 0) {
                    distance += this.calculateDistance(this.cities[routeIndices[routeIndices.length - 1]], this.cities[routeIndices[0]]);
                }
                return distance;
            }

            // Using Nearest Neighbor as it's computationally lighter for many cities
            nearestNeighborTSP() {
                if (this.cities.length < 2) return [];

                const unvisited = new Set(Array.from({ length: this.cities.length }, (_, i) => i));
                const route = [];
                let currentCityIndex = 0; // Start at city 0

                route.push(currentCityIndex);
                unvisited.delete(currentCityIndex);

                while (unvisited.size > 0) {
                    let nearest = -1;
                    let nearestDistance = Infinity;

                    for (const cityIndex of unvisited) {
                        const distance = this.calculateDistance(this.cities[currentCityIndex], this.cities[cityIndex]);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearest = cityIndex;
                        }
                    }
                    route.push(nearest);
                    unvisited.delete(nearest);
                    currentCityIndex = nearest;
                }
                return route;
            }
            
            // For a small number of cities, we can try brute force for true optimal (N! permutations)
            // Warning: Be very careful with `bruteForceTSP` as it's extremely slow for N > 10-12
            bruteForceTSP() {
                const numCities = this.cities.length;
                if (numCities < 2) return [];
                if (numCities > 8) { // Strict limit for performance in a game
                    console.warn("Brute force is too slow for more than 8 cities. Using Nearest Neighbor.");
                    return this.nearestNeighborTSP();
                }

                let smallestDistance = Infinity;
                let bestPermutation = [];

                // Generate all permutations using Heap's algorithm
                const swap = (arr, i, j) => {
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                };

                const permute = (arr, l, r) => {
                    if (l === r) {
                        const currentDistance = this.calculateRouteDistance(arr, true);
                        if (currentDistance < smallestDistance) {
                            smallestDistance = currentDistance;
                            bestPermutation = [...arr];
                        }
                    } else {
                        for (let i = l; i <= r; i++) {
                            swap(arr, l, i);
                            permute(arr, l + 1, r);
                            swap(arr, l, i); // Backtrack
                        }
                    }
                };

                const initialPermutation = Array.from({ length: numCities }, (_, i) => i);
                permute(initialPermutation, 0, numCities - 1);
                
                return bestPermutation;
            }


            solveTSP() {
                if (this.cities.length < 2) {
                    document.getElementById('gameFeedback').textContent = 'Add more cities to find an optimal route!';
                    return;
                }
                document.getElementById('gameFeedback').textContent = 'Calculating optimal route...';

                // Use brute force for small N, Nearest Neighbor for larger N
                const route = this.cities.length <= 8 ? this.bruteForceTSP() : this.nearestNeighborTSP();
                
                this.optimalDistance = this.calculateRouteDistance(route, true);
                this.optimalRoute = route;

                this.updateStats();
                this.draw();
                document.getElementById('gameFeedback').textContent = 'Optimal route displayed!';
            }

            draw() {
                // Cancel any ongoing line animations if we're doing a full redraw
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw optimal route (if exists)
                if (this.optimalRoute.length > 1 && this.optimalDistance < Infinity) {
                    this.ctx.strokeStyle = '#FFD700'; // Gold color for optimal
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([5, 5]); // Dashed line for optimal
                    this.ctx.beginPath();
                    for (let i = 0; i < this.optimalRoute.length; i++) {
                        const city = this.cities[this.optimalRoute[i]];
                        if (i === 0) {
                            this.ctx.moveTo(city.x, city.y);
                        } else {
                            this.ctx.lineTo(city.x, city.y);
                        }
                    }
                    if (this.optimalRoute.length > 0) {
                        const firstCity = this.cities[this.optimalRoute[0]];
                        this.ctx.lineTo(firstCity.x, firstCity.y);
                    }
                    this.ctx.stroke();
                }
                
                // Draw player's current route (non-animating parts)
                if (this.playerRoute.length > 1) {
                    this.ctx.strokeStyle = '#00ffff'; // Cyan for player's route
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([]); // Solid line for player
                    this.ctx.beginPath();
                    for (let i = 0; i < this.playerRoute.length; i++) {
                        const city = this.cities[this.playerRoute[i]];
                        if (i === 0) {
                            this.ctx.moveTo(city.x, city.y);
                        } else {
                            this.ctx.lineTo(city.x, city.y);
                        }
                    }
                    // Close the loop visually if ready for submission
                    const uniqueCitiesVisited = new Set(this.playerRoute).size;
                    if (uniqueCitiesVisited === this.cities.length && this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1]) {
                         const firstCity = this.cities[this.playerRoute[0]];
                         this.ctx.lineTo(firstCity.x, firstCity.y);
                    }
                    this.ctx.stroke();

                    // Draw direction arrows for player route
                    this.drawDirectionArrows(this.playerRoute, '#00ffff');
                }

                // Draw cities
                this.cities.forEach((city, index) => {
                    // City glow and animation
                    const baseRadius = 15;
                    const animatedRadius = baseRadius * city.animationProgress;
                    const animatedAlpha = city.animationProgress;

                    const radius = (this.currentHoverCity === index) ? (animatedRadius * 1.2) : animatedRadius;
                    
                    const glowGradient = this.ctx.createRadialGradient(city.x, city.y, 0, city.x, city.y, radius + 5);
                    glowGradient.addColorStop(0, `rgba(255, 255, 255, ${animatedAlpha * 0.9})`);
                    glowGradient.addColorStop(0.7, (this.currentHoverCity === index) ? `rgba(0, 255, 255, ${animatedAlpha})` : `rgba(135, 206, 235, ${animatedAlpha})`);
                    glowGradient.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = glowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(city.x, city.y, radius + 5, 0, 2 * Math.PI); // Larger outer glow
                    this.ctx.fill();

                    // Draw the themed city icon
                    this.drawCityIcon(this.ctx, city, radius, animatedAlpha);
                    
                    // City number (only if visible enough)
                    if (city.animationProgress > 0.8) {
                        this.ctx.fillStyle = '#000';
                        this.ctx.font = 'bold 13px Orbitron'; /* Font for city numbers */
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText((index + 1).toString(), city.x, city.y);
                    }
                });
            }

            drawDirectionArrows(routeIndices, color) {
                if (routeIndices.length < 2) return;

                this.ctx.fillStyle = color;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;

                const segmentsToDraw = routeIndices.length - 1;

                for (let i = 0; i < segmentsToDraw; i++) {
                    const currentCity = this.cities[routeIndices[i]];
                    const nextCity = this.cities[routeIndices[i + 1]];
                    
                    const dx = nextCity.x - currentCity.x;
                    const dy = nextCity.y - currentCity.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 30) {
                        const midX = currentCity.x + dx * 0.5; // Midpoint for arrow
                        const midY = currentCity.y + dy * 0.5;

                        const angle = Math.atan2(dy, dx);
                        const arrowLength = 10;
                        const arrowAngle = 0.5;

                        this.ctx.beginPath();
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle - arrowAngle),
                            midY - arrowLength * Math.sin(angle - arrowAngle)
                        );
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle + arrowAngle),
                            midY - arrowLength * Math.sin(angle + arrowAngle)
                        );
                        this.ctx.stroke();
                    }
                }
                // Draw closing arrow if applicable and not already drawn
                const uniqueCitiesVisited = new Set(routeIndices).size;
                if (uniqueCitiesVisited === this.cities.length && routeIndices[0] !== routeIndices[routeIndices.length - 1]) {
                    const currentCity = this.cities[routeIndices[routeIndices.length - 1]];
                    const nextCity = this.cities[routeIndices[0]];

                    const dx = nextCity.x - currentCity.x;
                    const dy = nextCity.y - currentCity.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 30) {
                        const midX = currentCity.x + dx * 0.5; // Midpoint for arrow
                        const midY = currentCity.y + dy * 0.5;

                        const angle = Math.atan2(dy, dx);
                        const arrowLength = 10;
                        const arrowAngle = 0.5;

                        this.ctx.beginPath();
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle - arrowAngle),
                            midY - arrowLength * Math.sin(angle - arrowAngle)
                        );
                        this.ctx.moveTo(midX, midY);
                        this.ctx.lineTo(
                            midX - arrowLength * Math.cos(angle + arrowAngle),
                            midY - arrowLength * Math.sin(angle + arrowAngle)
                        );
                        this.ctx.stroke();
                    }
                }
            }


            updateStats() {
                document.getElementById('cityCount').textContent = this.cities.length;
                document.getElementById('playerDistance').textContent =
                    this.playerDistance > 0 ? Math.round(this.playerDistance) : '0';
                document.getElementById('bestDistance').textContent =
                    this.optimalDistance < Infinity ? Math.round(this.optimalDistance) : '-';
                
                // Update goal message
                const goalMessageElement = document.getElementById('goalMessage');
                const uniqueCitiesVisited = new Set(this.playerRoute).size;

                if (this.currentFuel <= 0 && uniqueCitiesVisited < this.cities.length && this.cities.length > 0) {
                    goalMessageElement.textContent = 'Out of fuel!';
                    goalMessageElement.style.color = '#e74c3c'; // Red
                } else if (this.cities.length === 0) {
                    goalMessageElement.textContent = 'Place cities!';
                    goalMessageElement.style.color = '#00ffff';
                } else if (this.playerRoute.length === 0) {
                    goalMessageElement.textContent = 'Start plotting!';
                    goalMessageElement.style.color = '#00ffff';
                } else if (uniqueCitiesVisited < this.cities.length) {
                    goalMessageElement.textContent = `Visit ${this.cities.length - uniqueCitiesVisited} more!`;
                    goalMessageElement.style.color = '#00ffff';
                } else if (this.playerRoute[0] !== this.playerRoute[this.playerRoute.length - 1] && uniqueCitiesVisited === this.cities.length) {
                    goalMessageElement.textContent = 'Close the loop!';
                    goalMessageElement.style.color = '#00ffff';
                } else {
                    goalMessageElement.textContent = 'Submit your path!';
                    goalMessageElement.style.color = '#00ffff';
                }

                // Update Fuel Gauge
                const fuelGauge = document.getElementById('fuelGauge');
                const fuelLabel = document.getElementById('fuelLabel');
                const fuelPercentage = (this.currentFuel / this.maxFuel) * 100;
                fuelGauge.style.width = `${Math.max(0, fuelPercentage)}%`;
                fuelLabel.textContent = `${Math.round(this.currentFuel)} / ${this.maxFuel} units`;

                if (fuelPercentage <= 20) {
                    fuelGauge.classList.add('empty');
                } else {
                    fuelGauge.classList.remove('empty');
                }
            }
        }

        // --- Initialize everything when page loads ---
        document.addEventListener('DOMContentLoaded', function () {
            createStars();
            window.tspGame = new TSPGame();
            
            // Initial animation for sections
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1 }); // Trigger when 10% of element is visible

            document.querySelectorAll('.phase').forEach(phase => {
                observer.observe(phase);
            });
        });
    </script>
</body>
</html>
